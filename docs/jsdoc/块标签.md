### 1.@example    提供一个如何使用描述项的例子。 

**Overview（概述）**

 提供一个如何使用描述项的例子。跟随此标签的文字将显示为高亮代码。 

**Examples（例子）**

例1 一个doclet中可以同时使用多个`@example`标签。

```javascript
/**
 * Solves equations of the form a * x = b
 * @example
 * // returns 2
 * globalNS.method1(5, 10);
 * @example
 * // returns 3
 * globalNS.method(5, 15);
 * @returns {Number} Returns the value of x for the equation.
 */
globalNS.method1 = function (a, b) {
    return b / a;
};
```

例2  `@example`标签后面可以添加  标签作为示例的标题。 

```javascript
/**
 * Solves equations of the form a * x = b
 * @example <caption>Example usage of method1.</caption>
 * // returns 2
 * globalNS.method1(5, 10);
 * @returns {Number} Returns the value of x for the equation.
 */
globalNS.method1 = function (a, b) {
    return b / a;
};
```

### 2.@exports  标识一个由JavaScript模块导出的成员。 

**Syntax（语法）**

```javascript
 @exports <moduleName> 
```

 在JSDoc3.3.0或更高版本中，``可以包含`module:` 前缀。在以前的版本中，你必须忽略此前缀。 

**Overview（概述）**

 @exports标签描述由JavaScript模块的`exports`或`module.exports`属性导出的任何内容。 

**Examples（例子）**

 在模块中，当您使用特定的`exports`模块，@exports标签是不需要。JSDoc会自动识别出该对象的导出成员。同样，JSDoc会自动识别中的Node.js模块特定的`module.exports`属性。 

例如，CommonJS模块：

```javascript
/**
 * A module that says hello!
 * @module hello/world
 */

/** Say hello. */
exports.sayHello = function() {
    return 'Hello world';
};
```

例如，Node.js模块:

```javascript
/**
 * A module that shouts hello!
 * @module hello/world
 */

/** SAY HELLO. */
module.exports = function() {
    return "HELLO WORLD";
};
```

例如，AMD模块导出一个字面量对象：

```javascript
define(function() {

    /**
     * A module that whispers hello!
     * @module hello/world
     */
    var exports = {};

    /** say hello. */
    exports.sayHello = function() {
        return 'hello world';
    };

    return exports;
});
```

例如，AMD模块导出一个构造函数：

```javascript
define(function() {
    /**
     * A module that creates greeters.
     * @module greeter
     */

    /**
     * @constructor
     * @param {string} subject - The subject to greet.
     */
    var exports = function(subject) {
        this.subject = subject || 'world';
    };

    /** Say hello to the subject. */
    exports.prototype.sayHello = function() {
        return 'Hello ' + this.subject;
    };

    return exports;
});
```

如果你的模块导出使用的是`exports`或`module.exports`之外的其他方法，使用`@exports`标签来说明哪些成员用于导出。

例如：AMD模块导出一个对象：

```javascript
define(function () {

    /**
     * A module that says hello!
     * @exports hello/world
     */
    var ns = {};

    /** Say hello. */
    ns.sayHello = function() {
        return 'Hello world';
    };

    return ns;
});
```

### 3.@external   标识一个外部的类，命名空间，或模块。 

**别名**

 @host

**Syntax（语法）**

```javascript
@external <NameOfExternal>
```

**Overview（概述）**

 `@external`标签用来标识一个在当前包外部定义的类，命名空间，或模块。通过使用这个标签，你可以描述你的包的外部标识的扩展，或者您也可以提供关于 外部标识的相关信息给你的包的使用者。你也可以在任何其他JSDoc标签中引用外部标识的namepath（名称路径）。 

 外部标识引用的路径名 始终需要使用`external:`前缀：（例如`{@link external:Foo}`或`@augments external:Foo`）。 但是，你可以省略`@external`标记的这个前缀。 

 **注意：**您只能在你的项目之外定义的最高级别的标识上添加`@external`标签，请参见“描述一个嵌套的外部标识”的例子。 

**Examples（例子）**

下面的示例演示如何描述内置的String对象作为external，新的实例方法`external:String#rot13`。

例如，描述内置类添加方法：

```javascript
/**
 * The built in string object.
 * @external String
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String|String}
 */

/**
 * Create a ROT13-encoded version of the string. Added by the `foo` package.
 * @function external:String#rot13
 * @example
 * var greeting = new String('hello world');
 * console.log( greeting.rot13() ); // uryyb jbeyq
 */
```

下面的例子中描述一个新`starfairy`功能如何添加到外部的`jQuery.fn`命名空间。

例如，描述的外部的命名空间：

```javascript
/**
 * The jQuery plugin namespace.
 * @external "jQuery.fn"
 * @see {@link http://learn.jquery.com/plugins/|jQuery Plugins}
 */

/**
 * A jQuery plugin to make stars fly around your home page.
 * @function external:"jQuery.fn".starfairy
 */
```

在下面的例子中，`EncryptedRequest`类被描述为内置的`XMLHttpRequest`类的子类：

例如，扩展一个外部类：

```javascript
/**
 * The built-in class for sending HTTP requests.
 * @external XMLHttpRequest
 * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
 */

/**
 * Extends the built-in `XMLHttpRequest` class to send data encoded with a secret key.
 * @class EncodedRequest
 * @extends external:XMLHttpRequest
 */
```

您只能将`@external`标签添加到您的是项目定义的最外最顶层。在下面的例子中，描述的是外部的`security.TLS`类。其结果是，`@external`标签是用来描述外部的`external:security`命名空间，而*不*是外部类`external:security.TLS`。

例如，记录一个嵌套的外部标识：

```javascript
/**
 * External namespace for security-related classes.
 * @external security
 * @see http://example.org/docs/security
 */

/**
 * External class that provides Transport Layer Security (TLS) encryption.
 * @class TLS
 * @memberof external:security
 */
```

### 4.@file   描述一个文件。 

 **别名**

- @fileoverview
- @overview

**Overview（概述）**

 @file标签提供文件的说明。在文件开头的JSDoc注释部分使用该标签。 

**Example （例子）**

例如，文件描述：

```javascript
/**
 * @file Manages the configuration settings for the widget.
 * @author Rowina Sanela <rsanela@example.com>
 */
```

### 5.@fires   描述事件这个方法可能会触发。 

**别名**

 @emits 

**Syntax（语法）**

```javascript
@fires <className>#[event:]<eventName>
```

**Overview（概述）**

 `@fires`标签标明当一个方法被调用时将触发一个指定类型的事件，使用[@event 标签](https://www.html.cn/doc/jsdoc/tags-event.html)来描述事件的内容。 

**Examples（例子）**

例如，方法将触发"drain"事件：

```javascript
/**
 * Drink the milkshake.
 *
 * @fires Milkshake#drain
 */
Milkshake.prototype.drink = function() {
    // ...
};
```

### 6.@function  描述一个函数或方法。 

 **别名**

- @func
- @method

**Syntax（语法）**

```javascript
@function [<FunctionName>]
```

**Overview（概述）**

 @function标记一个对象作为一个函数，即使它可能不会出现在解析器中。它设置doclet的[@kind](https://www.html.cn/doc/jsdoc/tags-kind.html)为'function'。 

**Examples（例子）**

例如，使用@function标记为一个函数：

```javascript
/** @function */
var paginate = paginateFactory(pages);
```

如果没有@function标记，`paginate`对象将被记录为一个一般的对象（一个[@member](https://www.html.cn/doc/jsdoc/tags-member.html)），因为在这行代码运行时,它不可能分辨检查`paginate`是什么类型的值。

例如，使用带函数名的@function：

```javascript
/** @function myFunction */// 
the above is the same as:/** @function
 * @name myFunction */
```



### 7.@global   记录一个全局对象。 

**Overview（概述）**

 @global标签指定一个在文档的标识是为全局性的标识。JSDoc忽略这个标识在源文件中的实际作用范围。这个标记是在本地所定义标识时特别有用。 

**Examples（例子）**

使用@global标签来指定一个标识应记录为全局。

例如，文档中的内部变量作为一个全局变量：

```javascript
(function() {
    /** @global */
    var foo = 'hello foo';

    this.foo = foo;
}).apply(window);
```



### 8.@ignore   忽略文档中的一个标识。 

**Overview（概述）**

`@ignore`标签表示在你的代码中的注释不应该出现在文档中，注释会被直接忽略。这个标签优先于所有其他标签。

对于大多数JSDoc模板来说，包括默认模板，`@ignore`标签具有以下效果：

- 如果您和`@class`或`@module`标签结合使用`@ignore`标签，整个类或模块的JSDoc注释文档会被省略。
- 如果您和`@namespace`标签结合使用`@ignore`标签，你还必须将`@ignore`标签添加到任何子类和命名空间中。否则，会显示子类和命名空间的文档，但不完整。

**Examples（例子）**

在下面的例子中，`@ignore`标签， `Jacket` 和 `Jacket#color` 将不会出现在文档中：

例如，在Class中使用@ignore标签：

```javascript
/**
 * @class
 * @ignore
 */
function Jacket() {
    /** The jacket's color. */
    this.color = null;
}
```

在下面的例子中， `Clothes` 命名空间包含一个`Jacket`类。`@ignore`标签必须添加到`Clothes`和`Clothes.Jacket`中。`Clothes`, `Clothes.Jacket`和`Clothes.Jacket#color`将不会出现在文档

例如，带子类的命名空间：

```javascript
/**
 * @namespace
 * @ignore
 */
var Clothes = {
    /**
     * @class
     * @ignore
     */
    Jacket: function() {
        /** The jacket's color. */
        this.color = null;
    }
};
```

### 9.@implements  这个标识实现一个接口。   版本: '>=3.3.0' 

**Syntax（语法）**

```javascript
@implements {typeExpression}
```

**Overview（概述）**

`@implements`标签指示一个标识实现一个接口。

添加`@implements`标签到实现接口（例如，一个构造函数）的顶层标识。不需要将`@implements`标签添加到实现接口（例如，实现的实例方法）的每个成员上。

如果你没有在实现的接口中描述这个标识，JSDoc会自动使用该接口文档的标识。

**Examples（例子）**

在下面的例子中，`TransparentColor`类实现`Color`接口，并添加了`TransparentColor#rgba`方法。

例如，使用@implements标签：

```javascript
/**
 * Interface for classes that represent a color.
 *
 * @interface
 */
function Color() {}

/**
 * Get the color as an array of red, green, and blue values, represented as
 * decimal numbers between 0 and 1.
 *
 * @returns {Array&lt;number>} An array containing the red, green, and blue values,
 * in that order.
 */
Color.prototype.rgb = function() {
    throw new Error('not implemented');
};

/**
 * Class representing a color with transparency information.
 *
 * @class
 * @implements {Color}
 */
function TransparentColor() {}

// inherits the documentation from `Color#rgb`
TransparentColor.prototype.rgb = function() {
    // ...
};

/**
 * Get the color as an array of red, green, blue, and alpha values, represented
 * as decimal numbers between 0 and 1.
 *
 * @returns {Array&lt;number>} An array containing the red, green, blue, and alpha
 * values, in that order.
 */
TransparentColor.prototype.rgba = function() {
    // ...
};
```

### 10.@inheritdoc   指明这个标识应继承其父类的文档。  版本: '>=3.3.0' 

**Overview（概述）**

`@inheritdoc`标签指示该标识应继承其父类的文档。在你的JSDoc注释中的任何其它标签都将被忽略。

这个标签是为[Closure Compiler](https://developers.google.com/closure/compiler/)提供了兼容性。默认情况下，如果不给标识符加JSDoc注释，标识符将继承其父级的文档。

`@inheritdoc`标签的存在意味着[`@override` 标签](https://www.html.cn/doc/jsdoc/tags-override.html)存在。

**Examples（例子）**

下面的例子显示了一个类的描述如何从它的父类继承文档。

例如，一个类继承自他的父类：

```javascript
/**
 * @classdesc Abstract class representing a network connection.
 * @class
 */
function Connection() {}

/**
 * Open the connection.
 */
Connection.prototype.open = function() {
    // ...
};


/**
 * @classdesc Class representing a socket connection.
 * @class
 * @augments Connection
 */
function Socket() {}

/** @inheritdoc */
Socket.prototype.open = function() {
    // ...
};
```

省略`Socket#open`的JSDoc注释，你可以得到同样的结果。

例如, 没有`@inheritdoc`标签继承文档:

```javascript
/**
 * @classdesc Abstract class representing a network connection.
 * @class
 */
function Connection() {}

/**
 * Open the connection.
 */
Connection.prototype.open = function() {
    // ...
};


/**
 * @classdesc Class representing a socket connection.
 * @class
 * @augments Connection
 */
function Socket() {}

Socket.prototype.open = function() {
    // ...
};
```

### 11.@inner   描述一个内部对象。 

**Overview（概述）**

使用`@inner`标签将标明该标识符作为它父标识符的内部成员。这意味着它可以通过 "Parent~Child" 被引用。

使用`@inner`将重写的doclet的默认范围（除非它是全局性的，在这种情况下将保持全局性）。

**Examples（例子）**

例如，使用@inner使一个虚拟的doclet作为内部成员：

```javascript
/** @namespace MyNamespace */
/**
 * myFunction is now MyNamespace~myFunction.
 * @function myFunction
 * @memberof MyNamespace
 * @inner
 */
```

请注意，在上面的代码我们也可以使用 "@function MyNamespace~myFunction"，代替`@memberof`和`@inner`标签。

例如，使用@inner：

```javascript
/** @namespace */var MyNamespace = {
    /**
     * foo is now MyNamespace~foo rather than MyNamespace.foo.
     * @inner
     */
    foo: 1
    };
```

 在上面的例子中，我们使用@inner迫使一个命名空间的成员被描述作为内部成员（默认情况下，这是一个静态成员）。这意味着，`foo`现在有了`MyNamespace~foo`新名字，而不是`MyNamespace.foo`。 

### 12.@instance  记录一个实例成员。 

**Overview（概述）**

使用`@instance`标签标明该标识符作为它父标识符的实例成员。这意味着它可以通过"Parent#Child"被引用。

使用`@instance`将重写的doclet的默认范围（除非它是全局性的，在这种情况下将保持全局性）。

**Examples（例子）**

下面的例子是"@function MyNamespace#myFunction"的一个普通写法。

例如，使用 @instance 使一个虚拟的doclet作为实例成员，例如：

```javascript
/** @namespace MyNamespace */
/**
 * myFunction is now MyNamespace#myFunction.
 * @function myFunction
 * @memberof MyNamespace
 * @instance
 */
```

更有用的情况是，你可以使用@instance标签覆盖JSDoc推断的范围。例如，您可以指明一个静态成员被用作一个实例成员：

例如，使用@instance确定一个实例成员：

```javascript
/** @namespace */
var BaseObject = {
    /**
     * foo is now BaseObject#foo rather than BaseObject.foo.
     * @instance
     */
    foo: null
    };
    /** Generates BaseObject instances. */
    function fooFactory(fooValue) {
        var props = { 
        foo: fooValue 
        };    
        return Object.create(BaseObject, props);
}
```

### 13.@interface   这是别人可以实现的一个接口。  版本: '>=3.3.0' 

**Syntax（语法）**

用作JSDoc 标签字典 (默认开启):

```javascript
@interface []
```

用作[Closure Compiler](https://developers.google.com/closure/compiler/docs/js-for-compiler#tags) 标签字典:

```javascript
@interface
```

**Overview**

`@interface`标签使一个标识符作为其他标识符的一个实现接口。 例如，你的代码可能定义一个父类，它的方法和属性被去掉。您可以将`@interface`标签添加到父类，以指明子类必须实现父类的方法和属性。

作为接口，`@interface`标记应该添加到顶层标识符（例如，一个构造函数）。你并不需要将`@interface`标签添加到实现接口（例如，实现的实例方法）的每个成员上。

如果您使用的是JSDoc标记字典（默认启用），你还可以定义一个接口的虚拟注释，而不是为接口编写代码。见一个例子“定义一个接口的虚拟注释”。

**Examples（例子）**

在下面的例子中，`Color`函数表示其它类可以实现的接口。

例如，使用 @interface 标签：

```javascript
/**
 * Interface for classes that represent a color.
 *
 * @interface
 */
 function Color() {}
 /**
 * Get the color as an array of red, green, and blue values, represented as
 * decimal numbers between 0 and 1.
 *
 * @returns {Array&lt;number>} An array containing the red, green, and blue values,
 * in that order.
 */
 Color.prototype.rgb = function() {
     throw new Error('not implemented');
};
```

下面的例子使用虚拟注释，而不是代码，来定义`Color`接口。

例如，虚拟注释来定义一个接口：

```javascript
/**
 * Interface for classes that represent a color.
 *
 * @interface Color
 */
 /**
 * Get the color as an array of red, green, and blue values, represented as
 * decimal numbers between 0 and 1.
 *
 * @function
 * @name Color#rgb
 * @returns {Array<number>} An array containing the red, green, and blue values,
 * in that order.
 */
```



### 14.@kind   标识的类型。 

**Syntax（语法）**

```javascript
@kind <kindName> 
```

 `<kindName>` 取值为：

- class
- constant
- event
- external
- file
- function
- member
- mixin
- module
- namespace
- typedef

**Overview（概述）**

@kind标签是用来指明什么样的标识符被描述（例如，一类或模块）。标识符*kind* 不同于标识符*type*（例如，字符串或布尔）。

通常你不需要`@kind`标签，因为标识符的*kind*是由doclet的其他标记来确定。例如，使用`@class`标签自动意味着“@kind class”，使用`@namespace`标签则意味着“@kind namespace”。

**Examples（例子）**

 例如，使用 @kind： 

```javascript
// The following examples produce the same result:
/**
 * A constant.
 * @kind constant
 */
 const asdf = 1;
 /**
 * A constant.
 * @constant
 */
 const asdf = 1;
```

kind标签可能引起冲突（例如，使用 @module，表示他的kind为"module"，同时，又使用了"@kind constant"，表示他的kind为"constant"），在这种情况下最后的标签决定kind 的值。

例如，冲突的@kind语句：

```javascript
/**
 * This will show up as a constant
 * @module myModule
 * @kind constant
 */
 /**
 * This will show up as a module.
 * @kind constant
 * @module myModule
 */
```

### 15.@lends   将一个字面量对象的所有属性标记为某个标识符（类或模块）的成员。 

**语法**

```javascript
@lends <namepath>
```

**概述**

 `@lends`标签允许你将一个字面量对象的所有成员标记为某个标识符（类或模块）的成员，就像他们是给定名称的标识符成员。你可能想这样做，如果你传递一个对象字面量给一个函数，创建一个成员为对象字面量的命名类。 

**例子**

在这个例子中，我们要使用一个辅助函数创建一个名为"Person"的类，以及名为"initialize" 和 "say"的实例方法。类似于一些流行框架创建类的方式。

例如，给`makeClass`函数传入一个对象字面量，此对象字面量将会成为类`Person`的成员：

```javascript
// We want to document this as being a class
var Person = makeClass(
    // We want to document these as being methods
    {
        initialize: function(name) {
            this.name = name;
        },
        say: function(message) {
            return this.name + " says: " + message;
        }
    }
);
```

没有任何意见，JSDoc将无法识别该代码创建的一个`Person`类有两个方法。为了将他们正确文档化，我们需要在对象字面量紧邻的上方书写"@lends"的标签。`@lends`标签告诉JSDoc，这一对象字面量的所有成员都会被“借”给"Person"类。

下面的例子更加接近我们想要的，例如，描述静态方法：

```javascript
/** @class */
var Person = makeClass(
    /** @lends Person */
    {
        initialize: function(name) {
            this.name = name;
        },
        say: function(message) {
            return this.name + " says: " + message;
        }
    }
);
```

现在名为"initialize"和"say"的函数会被文档化，但它们被标记为"Person" 类的静态方法。这可能是你的意思，但有种情况下我们想要"initialize"和"say"属于"Person"类的实例。所以，我们通过少做改动,使其成为原型的方法。

例如，标注实例方法：

```javascript
/** @class */
var Person = makeClass(
    /** @lends Person.prototype */
    {
        initialize: function(name) {
            this.name = name;
        },
        say: function(message) {
            return this.name + " says: " + message;
        }
    }
);
```

最后一个步骤：我们类框架使用借来的"initialize"函数来构建`Person`类的实例，但一个Person实例不具有自己的"initialize"方法。该解决方案是将@constructs标签添加到借出去的函数上。请记住最好删除@class标签，否则两个类将被文档化。

例如，通过 constructor 文档化：

```javascript
var Person = makeClass(   
/** @lends Person.prototype */
    {       
     /** @constructs */
        initialize: function(name) {
                    this.name = name;
        },
        say: function(message) {
                    return this.name + " says: " + message;
        }
    }
);
```



### 16.@license   标识你的代码采用何种软件许可协议。 

**语法**

```javascript
@license <identifier>
```

**概述**

`@license`标签标识你的代码采用何种软件许可协议。

你可以用任何文本来明确您所使用的许可证。如果您的代码使用一个标准的开源许可，考虑使用 [Software Package Data Exchange (SPDX)许可列表](https://spdx.org/licenses/)中合适的标识符。 一些JavaScript处理工具，如谷歌的 Closure Compiler，会自动保留包含`@license`标签的JSDoc注释块。如果您在使用这些工具之一，您可能希望增加一个包含`@license`标签的独立的JSDoc注释块，后面加上许可的全部文本，从而使许可证文本将被包含在生成的JavaScript文件中。 

**例子**

例如，这是在Apache 2.0 许可下分发的模块：

```javascript
/**
 * Utility functions for the foo package.
 * @module foo/util
 * @license Apache-2.0
 */
```

 一个独立的JSDoc注释块，包含完整的MIT许可: 

```javascript
/**
 * @license
 * Copyright (c) 2015 Example Corporation Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
```

### 17.@listens   列出一个标识的监听事件。 

**语法**

```javascript
@listens <eventName>
```

**概述**

 `@listens` 标签指示一个标识监听指定的事件。使用[`@event 标签`](https://www.html.cn/doc/jsdoc/tags-event.html)来记录事件的内容。 

**例子**

 下面的示例演示了如何记录名为`module:hurler~event:snowball`的事件，还有一个方法命名为`module:playground/monitor.reportThrowage`来监听事件。 

 例如，描述一个事件和它的监听器: 

```javascript
define('hurler', [], function () {
    /**
     * Event reporting that a snowball has been hurled.
     *
     * @event module:hurler~snowball
     * @property {number} velocity - The snowball's velocity, in meters per second.
     */

    /**
     * Snowball-hurling module.
     *
     * @module hurler
     */
    var exports = {
        /**
         * Attack an innocent (or guilty) person with a snowball.
         *
         * @method
         * @fires module:hurler~snowball
         */
        attack: function () {
            this.emit('snowball', { velocity: 10 });
        }
    };

    return exports;
});

define('playground/monitor', [], function () {
    /**
     * Keeps an eye out for snowball-throwers.
     *
     * @module playground/monitor
     */
    var exports = {
        /**
         * Report the throwing of a snowball.
         *
         * @method
         * @param {module:hurler~event:snowball} e - A snowball event.
         * @listens module:hurler~event:snowball
         */
        reportThrowage: function (e) {
            this.log('snowball thrown: velocity ' + e.velocity);
        }
    };

    return exports;
});
```



### 18.@member   记录一个成员。 

 **别名**

- var

**语法**

```javascript
@member [<type>] [<name>]
```

**概述**

 `@member`标签记录成员基本种类（kind），比如"class", "function", 或者 "constant"。一个成员可以任选地具有一个类型以及名称。 

**例子**

例如，Data#point上使用@member：

```javascript
/** @class */
function Data() {
    /** @member {Object} */
    this.point = {};
}
```

下面是使用@var的一个例子，@member的别名，来描述一个（虚拟）变量'foo'。

例如：使用@var来记录一个虚拟成员：

```
/**
 * A variable in the global namespace called 'foo'.
 * @var {number} foo
 */
```

上面的例子等价于：

```javascript
/**
 * A variable in the global namespace called 'foo'.
 * @type {number}
 */
 var foo;
```

### 19.@memberof   标明这个标识属于哪个父级标识。 

**语法**

- `@memberof  <parentNamepath> ` 
- `@memberof!  <parentNamepath> `  

**概述**

@memberof标签标明成员隶属于哪一个父级标识符。

默认情况下，@memberof标签标注的标识符是静态成员。对于内部成员和实例成员，你可以使用对应名称路径的符号，或明确标注[@inner](https://www.html.cn/doc/jsdoc/tags-inner.html)或 [@instance](https://www.html.cn/doc/jsdoc/tags-instance.html)标签。

“强制的”@memberof标签，@memberof！强制对象被记录为属于特定的父级标识符，即使它有不同的父级标识符。

**例子**

在下面的例子中，`hammer`函数通常会被描述为一个全局性的函数。事实上，它就是一个全局性的函数，但同事它也是`Tools`命名空间的一个成员，而这才是你想描述的。解决方案就是增加一个`@memberof`标签。

例如，使用@memberof：

```javascript
/** @namespace */
var Tools = {};

/** @memberof Tools */
var hammer = function() {
};

Tools.hammer = hammer;
```

对于类的实例成员，可以使用语法："@memberof ClassName.prototype" 或者 "@memberof ClassName#"。另外也可以组合使用"@memberof ClassName"和"@instance" 达到同样的效果。

例如，在类原型上使用@memberof：

```javascript
/** @class Observable */
create(
    'Observable',
    {
        /**
         * This will be a static member, Observable.cache.
         * @memberof Observable
         */
        cache: [],

        /**
         * This will be an instance member, Observable#publish.
         * @memberof Observable.prototype
         */
        publish: function(msg) {},

        /**
         * This will also be an instance member, Observable#save.
         * @memberof Observable#
         */
        save: function() {},

        /**
         * This will also be an instance member, Observable#end.
         * @memberof Observable
         * @instance
         */
        end: function() {}
    }
);
```

下面的示例使用强制@memberof标签，“@memberof！”，来描述对象(Data#point)的属性，它是一个类（Data）的实例成员。

当您使用`@property`标签记录一个属性的时候，则无法使用其longname连接到这个属性。我们可以使用 "@alias" 和 "@memberof!" 来强制属性为可连接，告诉JSDoc Data#point.y 应记录为 "Data#" 的成员"point.y"而不是"Data#"的"point"中的一员"y"。

例如，为对象属性使用@memberof!：

```javascript
/** @class */
function Data() {
    /**
     * @type {object}
     * @property {number} y This will show up as a property of `Data#point`,
     * but you cannot link to the property as {@link Data#point.y}.
     */
    this.point = {
        /**
         * The @alias and @memberof! tags force JSDoc to document the
         * property as `point.x` (rather than `x`) and to be a member of
         * `Data#`. You can link to the property as {@link Data#point.x}.
         * @alias point.x
         * @memberof! Data#
         */
        x: 0,
        y: 1
    };
}
```

### 20.@mixes   此对象混入了另一个对象中的所有成员。 

**语法**

```javascript
@mixes <OtherObjectPath>
```

**概述**

 @mixes标签指示当前对象混入了`OtherObjectPath`对象的所有成员,被混入的对象就是一个[@mixin](https://www.html.cn/doc/jsdoc/tags-mixin.html)。 

**例子**

首先，我们用[@mixin](https://www.html.cn/doc/jsdoc/tags-mixin.html)标签描述一个混入：

```javascript
/**
 * This provides methods used for event handling. It's not meant to
 * be used directly.
 *
 * @mixin
 */var Eventful = {    
 /**
     * Register a handler function to be called whenever this event is fired.
     * @param {string} eventName - Name of the event.
     * @param {function(Object)} handler - The handler to call.
     */
    on: function(eventName, handler) {        // code...
    },    
    /**
     * Fire an event, causing all handlers for that event name to run.
     * @param {string} eventName - Name of the event.
     * @param {Object} eventData - The data provided to each handler.
     */
    fire: function(eventName, eventData) {        // code...
    }
};
```

现在，我们添加一个FormButton类，并且调用"mix"函数，将Eventful的所有功能混入到FormButton，这样FormButton也可以触发事件和监听了。我们使用@mixes标签，以表明FormButton混入了Eventful的功能。

例如，使用@mixes标签：

```javascript
/**
 * @constructor FormButton
 * @mixes Eventful
 */
var FormButton = function() {
    // code...
};
FormButton.prototype.press = function() {
  this.fire('press', {});
}
mix(Eventful).into(FormButton.prototype);
```

### 21.@mixin   记录一个mixin（混入）对象。 

**语法**

```javascript
@mixin [<MixinName>]
```

**概述**

 您可以使用@mixin标签标识该对象是一个mixin（混入），旨在表明该对象的属性和方法混入到其他对象。然后，可以将@mixes标签 添加到使用了该 mixin（混入）的对象上。 

**例子**

例如，使用 @mixin :

```javascript
/**
 * This provides methods used for event handling. It's not meant to
 * be used directly.
 *
 * @mixin
 */
var Eventful = {
    /**
     * Register a handler function to be called whenever this event is fired.
     * @param {string} eventName - Name of the event.
     * @param {function(Object)} handler - The handler to call.
     */
    on: function(eventName, handler) {
        // code...
    },
    /**
     * Fire an event, causing all handlers for that event name to run.
     * @param {string} eventName - Name of the event.
     * @param {Object} eventData - The data provided to each handler.
     */
    fire: function(eventName, eventData) {
        // code...
    }
};
```

### 22.@module   记录一个 JavaScript 模块。 

**语法**

```javascript
@module [[{<type>}] <moduleName>]
```

在JSDoc3.3.0或更高版本中，``可能包括`module:`前缀。在以前的版本中，你必须忽略此前缀。

注意：如果你提供了一个type，那 *必须* 同时提供模块名称（``）。

**概述**

@module可以将当前文件标注为一个模块，默认情况下文件内的所有标识符都隶属于此模块，除非文档另有说明。

链接到模块(比如使用 [@link](https://www.html.cn/doc/jsdoc/tags-inline-link.html)或者 [@see](https://www.html.cn/doc/jsdoc/tags-see.html) 标签)使用"module:moduleName"。例如，可以使用"{@link module:foo/bar}"链接到"@module foo/bar"。

如果未提供模块的名称，那么JSDoc将从模块的路径和文件名获得模块名称。例如，假设`src`目录下有一个文件`test.js`，包含块注释`/** @module */`。这些场景运行下运行JSDoc,test.js产生的模块名称请看下面的代码：

例如，如果没有提供导出模块的名称：

```javascript
# from src/
jsdoc ./test.js   # module name 'test'

# from src's parent directory:
jsdoc src/test.js # module name 'src/test'
jsdoc -r src/     # module name 'test'
```

**例子**

下面的示例演示了在一个模块中用于标识的namepaths。第一个标识符是模块私有的，或“内部”变量 - 它只能在模块内访问。第二个标识符是由模块导出一个静态函数。

例如，使用基础的@module ：

```javascript
/** @module myModule */
/** will be module:myModule~foo */
var foo = 1;
/** will be module:myModule.bar */
var bar = function() {};
```

当一个导出的标识符被定义为`module.exports`，`exports`，或`this`中的成员，JSDoc会推断该标识符是模块的静态成员。

在下面的例子中，Book类被描述为一个静态成员，"module:bookshelf.Book"，带有一个实例成员，"module:bookshelf.Book#title"。

例如，定义导出的标识符为'this'的成员：

```javascript
/** @module bookshelf */
/** @class */
this.Book = function (title) {
    /** The title. */
    this.title = title;
};
```

在下面的例子中，两个函数有namepaths（名称路径）"module:color/mixer.blend"和"module:color/mixer.darken"。

例如，定义导出的标识符为`module.exports`或`exports`的成员:

```javascript
/** @module color/mixer */
module.exports = {
    /** Blend two colours together. */
    blend: function (color1, color2) {}
};
/** Darkens a color. */
exports.darken = function (color, shade) {};
```

 更多例子查看 [描述 JavaScript 模块](https://www.html.cn/doc/jsdoc/howto-commonjs-modules.html) 。 

### 23.@name   记录一个对象的名称。 

**语法**

```javascript
@name <namePath>
```

**概述**

@name标签强制JSDoc使用这个给定的名称，而忽略实际代码里的名称。这个标签最好用于"虚拟注释"，而不是在代码中随时可见的标签，如在运行时期间产生的方法。

当您使用@name标签，你必须提供额外的标签，来告诉JSDoc什么样的标识符将被文档化;该标识符是否是另一个标识符的成员;等等。如果不提供这些信息，标识符将不会被正确文档化。

**警告**：通过使用@name标签，你告诉JSDoc忽略实际代码，隔离您的文档注释。在许多情况下，最好是使用[@alias 标签](https://www.html.cn/doc/jsdoc/tags-alias.html) 代替，这个标签只是改变了标识符的名称，但是保留了标识符的其他信息。

**例子**

下面的例子演示了如何使用@name标签描述一个函数，JSDoc通常不会识别。

例如，使用@name标签：

```javascript
/**
 * @name highlightSearchTerm
 * @function
 * @global
 * @param {string} term - The search term to highlight.
 */
 eval("window.highlightSearchTerm = function(term) {};")
```

### 24.@namespace  录一个命名空间对象。 

**语法**

```javascript
@namespace [{<type>}] <SomeName>]
```

**概述**

@namespace标签指明对象是一个命名空间。你也可以书写一个虚拟JSDoc注释，通过使用代码来定义命名空间。

如果一个命名空间是由除对象字面量以为的标识符定义的，您可以包括一个 type 的表达式，跟在@namespace标签后面。如果@namespace标签包括一个type，那么它也必须包含一个名称。

您可能需要描述一个命名空间，其名称中包含特殊字符，如"#" 或 "!"。在这些情况下，当你的描述或链接到这个命名空间时，你必须将命名空间中特殊符号部分使用双引号括起来。详情参见下面的例子。

**例子**

例如，对象上使用 @namespace 标签：

```javascript
/**
 * My namespace.
 * @namespace
 */
 var MyNamespace = {
     /** documented as MyNamespace.foo */
    foo: function() {},    
    /** documented as MyNamespace.bar */
    bar: 1};
```

为虚拟注释加上 @namespace 标签：

```javascript
/**
 * A namespace.
 * @namespace MyNamespace
 */
 /**
 * A function in MyNamespace (MyNamespace.myFunction).
 * @function myFunction
 * @memberof MyNamespace
 */
```

如果 @namespace 的名称包括特殊字符，你必须将命名空间中特殊符号部分使用双引号括起来。如果名称已经包含一个或多个双引号，那么使用反斜线（\）转义双引号。

例如，在不寻常的成员名称上使用@namespace标签：

```javascript
/** @namespace window */
/**
 * Shorthand for the alert function.
 * Refer to it as {@link window."!"} (note the double quotes).
 */
 window["!"] = function(msg) { alert(msg); };
```

### 25.@override   指明一个标识符覆盖其父类同名的标识符。 

 字典: 

```javascript
- closure
```

 版本: '>=3.3.0' 

**概述**

`@override`标签指明一个标识符覆盖其父类同名的标识符。

这个标签为[Closure Compiler](https://developers.google.com/closure/compiler/)提供了兼容性。默认情况下，JSDoc自动识别，覆盖其父类同名的标识符。

如果您的JSDoc注释块包含[`@inheritdoc` 标签](https://www.html.cn/doc/jsdoc/tags-inheritdoc.html)，就不需要在包含`@Override`标签了。`@inheritdoc`标签的存在就意味着`@override`的存在。

**例子**

下面的例子说明一个方法如何重写父类的方法。

例如，重写父类方法：

```javascript
/**
 * @classdesc Abstract class representing a network connection.
 * @class
 */
 function Connection() {}
 /**
 * Open the connection.
 */
 Connection.prototype.open = function() {
     // ...
     };
/**
 * @classdesc Class representing a socket connection.
 * @class
 * @augments Connection
 */
 function Socket() {}
 /**
 * Open the socket.
 * @override
 */
 Socket.prototype.open = function() {
     // ...
     };
```



### 26.@param   记录传递给一个函数的参数。

 **别名**

- arg
- argument

**概述**

`@param`标签提供了对某个函数的参数的各项说明，包括参数名、参数数据类型、描述等。

`@param`标签要求您指定要描述参数的名称。您还可以包含参数的数据类型，使用大括号括起来，和参数的描述。

参数类型可以是一个内置的JavaScript类型，如`string`或`Object`，或是你代码中另一个标识符的[JSDoc namepath（名称路径）](https://www.html.cn/doc/jsdoc/about-namepaths.html)。如果你已经在这namepath（名称路径）上为标识符添加了描述，JSDoc会自动链接到该标识符的文档。您还可以使用type的表达式来表示，例如，该参数不能为空或可以接受任何类型;详见[`@type` 标签文档](https://www.html.cn/doc/jsdoc/tags-type.html)。

如果您提供的描述，在描述之前插入一个连字符，可以使JSDoc注释更具可读性。请务必在连字符后加一个空格。

**例子**

名称, 类型, 和说明

下面的示例演示如何在 `@param`标签中包含名称，类型，和说明。

只注释变量名称,例如：

```javascript
/**
 * @param somebody
 */
 function sayHello(somebody) {
    alert('Hello ' + somebody);
}
```

注释变量名 和 变量类型 ,例如：

```javascript
/**
 * @param {string} somebody
 */
 function sayHello(somebody) {
    alert('Hello ' + somebody);
}
```

注释变量名 、 变量类型 和 变量说明 ,例如：

```javascript
/**
 * @param {string} somebody Somebody's name.
 */
 function sayHello(somebody) {
    alert('Hello ' + somebody);
}
```

你可以在变量说明前加个连字符，使之更加容易阅读， 例如：

```javascript
/**
 * @param {string} somebody - Somebody's name.
 */
 function sayHello(somebody) {
    alert('Hello ' + somebody);
}
```

变量是一个对象，带属性

如果参数是一个对象，有特定的属性，您可以通过`@param`标签提供额外的属性。例如，假如`employee`参数有`name`和`department`属性，您可以按以下方式描述。

例如，描述一个对象参数的属性：

```javascript
/**
 * Assign the project to an employee.
 * @param {Object} employee - The employee who is responsible for the project.
 * @param {string} employee.name - The name of the employee.
 * @param {string} employee.department - The employee's department.
 */
 Project.prototype.assign = function(employee) {    // ...};
```

同样，可以联想到如果假如`employee`参数是一个数组，这个数组中包含`name`和`department`元素，那么可以这么描述。

例如，描述参数的属性值在数组中：

```javascript
/**
 * Assign the project to a list of employees.
 * @param {Object[]} employees - The employees who are responsible for the project.
 * @param {string} employees[].name - The name of an employee.
 * @param {string} employees[].department - The employee's department.
 */Project.prototype.assign = function(employees) {    // ...};
```

可选参数和默认值

下面的例子说明如何描述一个参数是可选的，并且具有默认值。

一个可选参数（使用JSDoc语法），例如：

```javascript
/**
 * @param {string} [somebody] - Somebody's name.
 */
 function sayHello(somebody) {
     if (!somebody) {
        somebody = 'John Doe';
    }
    alert('Hello ' + somebody);
}
```

一个可选参数（ 使用Google Closure Compiler 语法）：

```javascript
/**
 * @param {string=} somebody - Somebody's name.
 */
 function sayHello(somebody) {
     if (!somebody) {
        somebody = 'John Doe';
    }
    alert('Hello ' + somebody);
}
```

一个可选参数和默认值：

```javascript
/**
 * @param {string} [somebody=John Doe] - Somebody's name.
 */
 function sayHello(somebody) {
     if (!somebody) {
        somebody = 'John Doe';
    }
    alert('Hello ' + somebody);
}
```

多少类型参数和可重复使用的参数

下面的例子演示了如何使用类型的表达式来表示一个参数可以接受多种类型（或任何类型），还有一个参数可以被多次使用。有关JSDoc支持的类型表达式细节请参阅[`@type` 标签文档](https://www.html.cn/doc/jsdoc/tags-type.html)。

例如，允许一个类型或另一个类型：

```
/**
 * @param {(string|string[])} [somebody=John Doe] - Somebody's name, or an array of names.
 */
 function sayHello(somebody) {
     if (!somebody) {
        somebody = 'John Doe';
    } else if (Array.isArray(somebody)) {
        somebody = somebody.join(', ');
    }
    alert('Hello ' + somebody);
}
```

例如，允许任何类型：

```javascript
/**
 * @param {*} somebody - Whatever you want.
 */
 function sayHello(somebody) {
     console.log('Hello ' + JSON.stringify(somebody));
}
```

例如，可重复使用的参数：

```javascript
/**
 * Returns the sum of all numbers passed to the function.
 * @param {...number} num - A positive or negative number.
 */
 function sum(num) {
     var i = 0, n = arguments.length, t = 0;    
     for (; i &lt; n; i++) {
        t += arguments[i];
    }    
    return t;
}
```

回调函数

如果参数接受一个回调函数，您可以使用[`@callback`标签](https://www.html.cn/doc/jsdoc/tags-callback.html)来定义一个回调类型，然后回调类型包含到`@param`标签中。

例如，参数接受一个回调函数：

```java
/**
 * This callback type is called `requestCallback` and is displayed as a global symbol.
 *
 * @callback requestCallback
 * @param {number} responseCode
 * @param {string} responseMessage
 */
 /**
 * Does something asynchronously and executes the callback on completion.
 * @param {requestCallback} cb - The callback that handles the response.
 */
 function doSomethingAsynchronously(cb) {
     // code
     };
```

### 27.@private   标记为私有

**语法**

使用JSDoc标签字典（默认启用）：

```
@private
```

使用[Closure Compiler](https://developers.google.com/closure/compiler/docs/js-for-compiler#tags)标签字典：

```javascript
@private [{typeExpression}]
```

**概述**

`@private`标签标记标识符为私有，或者不作一般用途使用。私有成员不会在生成文档中输出任何内容，除非JSDoc使用 `-p/--private` 命令行选项运行。在JSDoc3.3.0或更高版本中，您还可以使用 [`-a/--access` 命令行选项](https://www.html.cn/doc/jsdoc/about-commandline.html)来改变这种行为。

`@private`标签不被子成员继承。 例如，如果@private标记添加到命名空间，命名空间的成员仍然会输出到生成的文档中;因为命名空间是私有的，成员的 namepath 不包含在命名空间中。

`@private`标签和`@access private`是等价的。

**例子**

在下面的例子中，`Documents`和`Documents.Newspaper`会被输出到生成的文档中，但是`Documents.Diary`不会。

例如：

```javascript
/** @namespace */
var Documents = {
    /**
     * An ordinary newspaper.
     */
    Newspaper: 1,    
    /**
     * My diary.
     * @private
     */
    Diary: 2
    };
```

### 28.@property   记录一个对象的属性。 

 **别名**

- prop

**概述**

@property标签很容易描述类，命名空间或其它对象的静态属性列表。

通常JSDoc模板将创造一个全新的页面来显示关于命名空间嵌套的每一层级的信息。有时候，你真的想要在同一张页面上列出所有属性，包括嵌套的属性。

请注意，@property标记必须在命名空间或类的文档注释块中使用。该标签适用于静态属性的简单集合，它不允许你为每个属性提供@examples或类似的复杂信息，只包含类型，名称和说明。

**例子**

在这个例子中，我们有一个名为"config"的命名空间。我们想要所有有关默认属性及嵌套值的信息，输出到与"config"同一个页面上。

例如，描述命名空间的默认属性及嵌套属性：

```javascript
/**
 * @namespace
 * @property {object}  defaults               - The default values for parties.
 * @property {number}  defaults.players       - The default number of players.
 * @property {string}  defaults.level         - The default level for the party.
 * @property {object}  defaults.treasure      - The default treasure.
 * @property {number}  defaults.treasure.gold - How much gold the party starts with.
 */
var config = {
    defaults: {
        players: 1,
        level:   'beginner',
        treasure: {
            gold: 0
        }
    }
};
```

### 29.@protected   这个标识是受保护的。 

**语法**

使用JSDoc标签字典（默认启用）：

```javascript
@protected
```

使用[Closure Compiler](https://developers.google.com/closure/compiler/docs/js-for-compiler#tags)标签字典：

```javascript
@protected [{typeExpression}]
```

**概述**

`@protected`标签标记标识符为受保护的，通常情况下，受保护的成员只能在被继承的子类中或在模块内部可以访问。

默认情况下，使用 `@protected` 标签标记的标识符将会被导出到生成的文档中。在JSDoc3.3.0或更高版本中，您还可以使用 [`-a/--access` 命令行选项](https://www.html.cn/doc/jsdoc/about-commandline.html)来改变这种行为。

`@protected`标签和`@access protected`是等价的。

**例子**

在下面的例子中，该实例成员`Thingy#_bar`会被导出到生成的文档中，但使用注释说明它是被保护的， 例如，使用@protected 标签：

```javascript
/** @constructor */
function Thingy() {
    /** @protected */    
    this._bar = 1;
}
```

### 30.@public   标记为公开的。 

**概述**

`@public`标签标记标识符为公开的。

默认情况下，JSDoc把所有标识符当做公开的，因此使用这个标记一般不会影响生成的文档。 然而，你可能更愿意明确地使用 `@public` 标签，这样可以更加清晰的标明你要公开的标识符。

在JSDoc 3中，`@public`标签不影响标识符的作用域。使用[`@instance`](https://www.html.cn/doc/jsdoc/tags-instance.html), [`@static`](https://www.html.cn/doc/jsdoc/tags-static.html), 和 [`@global`](https://www.html.cn/doc/jsdoc/tags-global.html)标签会改变标识符的作用域。

**例子**

使用 @public 标签：

```javascript
/**
 * The Thingy class is available to all.
 * @public
 * @class
 */
 function Thingy() {
     /**
     * The Thingy~foo member. Note that 'foo' is still an inner member
     * of 'Thingy', in spite of the @public tag.
     * @public
     */    
     var foo = 0;
}
```

### 31.@readonly   标记为只读的。 

**概述**

标记一个标识符为只读。jsdoc不会检查某个代码是否真是只读的，只要标上@readonly，在文档中就体现为只读的。 

**例子**

例如，使用@readonly标签：

```javascript
/**
 * A constant.
 * @readonly
 * @const {number}
 */
 const FOO = 1;
```

例如，给getter标记为只读：

```javascript
/**
 * Options for ordering a delicious slice of pie.
 * @namespace
 */var pieOptions = {
/**
 * Plain.
 */
    plain: 'pie',    
/**
 * A la mode.
 * @readonly
 */
    get aLaMode() {
            return this.plain + ' with ice cream';
    }
};
```

### 32.@requires  这个文件需要一个 JavaScript 模块。 

**语法**

```javascript
@requires <someModuleName>
```

**概述**

@requires标签可以记录一个模块需要的依赖项。一个JSDoc注释块可以有多个@require标签。模块名可以被指定为 "moduleName" 或者 "module:moduleName";这两种形式将被解析为模块。

JSDoc不会尝试处理被包含的模块。如果您希望该模块包含到文档中，您必须将模块包含到JavaScript文件列表进行处理。

**例子**

例如，使用@requires 标签

```javascript
/**
 * This class requires the modules {@link module:xyzcorp/helper} and
 * {@link module:xyzcorp/helper.ShinyWidget#polish}.
 * @class
 * @requires module:xyzcorp/helper
 * @requires xyzcorp/helper.ShinyWidget#polish
 */
 function Widgetizer() {}
```

### 33.@returns   记录一个函数的返回值。 

 **别名**

- return

**概述**

 @returns 标签描述一个函数的返回值。语法和@param类似。 

**例子**

返回值的类型，例如：

```javascript
/**
 * Returns the sum of a and b
 * @param {Number} a
 * @param {Number} b
 * @returns {Number}
 */
 function sum(a, b) {
     return a + b;
}
```

返回值的类型和描述，例如：

```javascript
/**
 * Returns the sum of a and b
 * @param {Number} a
 * @param {Number} b
 * @returns {Number} Sum of a and b
 */
 function sum(a, b) {
     return a + b;
}
```

返回值可以有不同的类型，例如：

```javascript
/**
 * Returns the sum of a and b
 * @param {Number} a
 * @param {Number} b
 * @param {Boolean} retArr If set to true, the function will return an array
 * @returns {Number|Array} Sum of a and b or an array that contains a, b and the sum of a and b.
 */
 function sum(a, b, retArr) {
     if (retArr) {
             return [a, b, a + b];
    }    
    return a + b;
}
```

### 34.@see   更多详细信息请参阅其他一些文档。 

**语法**

- `@see  <namepath>  `
- `@see   <text> `

**概述**

 @see标签表示可以参考另一个标识符的说明文档，或者一个外部资源。您可以提供一个标识符的namepath或自由格式的文本。如果你提供了一个namepath，JSDoc的默认模板会自动将namepath转换成链接。 

**例子**

例如，使用@see标签：

```javascript
/**
 * Both of these will link to the bar function.
 * @see {@link bar}
 * @see bar
 */
 function foo() {}
 // Use the inline {@link} tag to include a link within a free-form description.
 /**
 * @see {@link foo} for further information.
 * @see {@link http://github.com|GitHub}
 */
 function bar() {}
```

### 35.@since   此功能何时被添加进来的? 

 **语法**

```javascript
@since <versionDescription>
```

**概述**

 @since标签标明一个类，方法，或其它标识符是在哪个特定版本开始添加进来的。 

**例子**

例如，使用@since标签：

```javascript
/**
 * Provides access to user information.
 * @since 1.0.1
 */
 function UserRecord() {}
```

### 36.@static   记录一个静态成员。 

**概述**

@static标签标明一个在父类中的标识符不需实例即可使用。

使用@static标签将重写标识符的默认作用域，但有一个例外：在全局作用域下的标识符将保持他的全局性。

**例子**

下面的例子可以写成 "@function MyNamespace.myFunction" 并省略@memberof和@static标签，他们的效果是一样的：

例如，在一个虚拟注释中使用@static:

```javascript
/** @namespace MyNamespace */
/**
 * @function myFunction
 * @memberof MyNamespace
 * @static
 */
```

下面的示例强制模块的内部成员被描述为静态成员。

例如，使用@static来覆盖默认作用域：

```javascript
/** @module Rollerskate */
/**
 * The 'wheel' variable is documented as Rollerskate.wheel
 * rather than Rollerskate~wheel.
 * @static
 */
 var wheel = 1;
```

### 37.@summary   完整描述的一个简写版本。 

**语法**

```javascript
@summary Summary goes here.
```

**概述**

 @summary标签是完整描述的一个简写版本。它可以被添加到任何的doclet。 

**例子**

```javascript
/**
 * A very long, verbose, wordy, long-winded, tedious, verbacious, tautological,
 * profuse, expansive, enthusiastic, redundant, flowery, eloquent, articulate,
 * loquacious, garrulous, chatty, extended, babbling description.
 * @summary A concise summary.
 */
 function bloviate() {}
```

### 38.@this   `this`关键字的指向 

**语法**

```javascript
@this <namePath>
```

**概述**

 @this标签指明`this`关键字的指向。 

**例子**

在下面的例子中，@this标签迫使"this.name"被描述为"Greeter#name"，而不是全局变量"name"。

```javascript
/** @constructor */
function Greeter(name) {
    setName.apply(this, name);
}
/** @this Greeter */
function setName(name) {
    /** document me */    
    this.name = name;
}
```

### 39.@throws   说明可能会被抛出什么样的错误。 

**别名**

- exception

**语法**

```javascript
@throws free-form description
@throws {<type>}
@throws {<type>} free-form description
```

**概述**

 @throws标签可以让你描述函数可能会抛出的错误。在一个JSDoc注释块中您可以包含多个@throws标签。 

**例子**

例如，在type中使用@throws标签:

```javascript
/**
 * @throws {InvalidArgumentException}
 */
 function foo(x) {}
```



例如，在描述中使用@throws标签:

```javascript
/**
 * @throws Will throw an error if the argument is null.
 */
 function bar(x) {}
```

例如，在type和描述中使用@throws标签:

```javascript
/**
 * @throws {DivideByZero} Argument x must be non-zero.
 */
 function baz(x) {}
```

### 40.@todo   记录一个将要完成的任务。 

**语法**

```javascript
@todo text describing thing to do.
```

**概述**

 @todo标签可以让你记录要完成的任务。在一个JSDoc注释块中您可以包含多个@todo标签。 

**Examples**

例如，使用@todo标签：

```javascript
/**
 * @todo Write the documentation.
 * @todo Implement this function.
 */
 function foo() {
     // write me
     }
```

### 41.@tutorial   插入一个链接到包含教程文件。 

**语法**

```javascript
@tutorial <tutorialID>
```

**概述**

`@tutorial` 标签插入一个指向向导教程的链接，作为文档的一部分。有关创建教程指导请参阅[tutorials overview](https://www.html.cn/doc/jsdoc/about-tutorials.html)。

在一个JSDoc注释块中您可以包含多个`@tutorial`标签。

**例子**

在下面的例子中，`MyClass`的文档将链接到`tutorial-1` 和 `tutorial-2`标识符的教程。

例如，使用 @tutorial 标签：

```javascript
/**
 * Description
 * @class
 * @tutorial tutorial-1
 * @tutorial tutorial-2
 */
 function MyClass() {}
```

### 42.@type   记录一个对象的类型。 

**语法**

```javascript
@type {typeName}
```

**概述**

@type标签允许你提供一个表达式，用于标识一个标识符可能包含的值的类型，或由函数返回值的类型。您还可以将其包含与其他JSDoc标签类型的表达式结合使用，如[@param ](https://www.html.cn/doc/jsdoc/tags-param.html)标签。

类型表达式可以包括标识符的namepath（例如，`myNamespace.MyClass`）;一个内置的JavaScript类型（例如，`string`）;或这些的组合。你可以使用任何[Google Closure Compiler 的类型表达式](https://developers.google.com/closure/compiler/docs/js-for-compiler#types)，还有其他几种JSDoc所特有的格式。

如果JSDoc确定一个类型表达式是无效的，它会显示一个错误并停止运行。您可以通过与`--lenient`选项运行JSDoc把这个错误变成警告。

**注意**：在JSDoc3.2及更高版本完全支持Google Closure Compiler风格的类型表达式。早期版本的JSDoc支持部分的Google Closure Compiler类型表达式。

每种类型是通过使用下面描述的格式之一，提供一个类型表达式指定的。 在适当情况下，JSDoc将自动创建链接到其他标识符的文档。例如，`@type {MyClass}`将链接到MyClass的文档，如果该标识符已经被文档化。

| 类型名                                                  | 语法示例                                                     | 描述                                                         |
| :------------------------------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Symbol name (name expression)                           | {boolean} {myNamespace.MyClass}                              | 指定符号的名称。 如果标识符已经被文档化，JSDoc将创建一个链接到该标识符的文档。 |
| Multiple types (type union)                             | {(number\|boolean)} 表示数字或布尔                           | 这意味着值可能是几种类型中的一种，用括号括起来，并用"\|"分隔类型的完整列表。 |
| Arrays and objects (type applications and record types) | MyClass的实例的数组 {Array.} // or: {MyClass[]} 具有字符串键和数字值的对象： {Object.} 对象“MyObj”中具有属性 'a' (一个数字), 'b' (一个字符串) 和 'c' (任何类型) {a: number, b: string, c} myObj // or: {Object} myObj {number} myObj.a {string} myObj.b {} myObj.c | JSDoc支持 Closure Compiler 语法定义的数组和对象类型。还可以通过array后面附加`[]`指示包含在数组中的类型。例如，表达式`string[]`表示字符串数组。对于具有一组已知的属性的对象，你可以使用 Closure Compiler 语法文档化标注的类型。您可以分别描述每个属性，这使您能够提供有关每个属性的更多详细信息。 |
| Nullable type                                           | 一个数字或null  {?number}                                    | 指明类型为指定的类型，或者为null。                           |
| Non-nullable type                                       | 一个数字，但是绝对不会是null  {!number}                      | 指明类型为指定的类型，但是绝对不会是null。                   |
| Variable number of that type                            | 此函数接受可变数量的数值参数。<br>@param {...number} num     | 表示该函数接受可变数量的参数，并指定一个类型的参数。 例如： /** *  Returns the sum of all numbers passed to the function. *  @param {...number} num A positive or negative number */ function sum(num) {   var i=0, n=arguments.length, t=0;   for (; i<n; i++)="" {t += arguments[i];   }   return t; } |
| Optional parameter                                      | 一个可选参数“foo”<br>@param {number} [foo] // or:<br>@param {number=} foo 一个可选参数“foo”,默认值为1。<br>@param {number} [foo=1] | 指示参数是可选的。当使用JSDoc的语法表示可选参数时，你还可以指明参数的默认值。 |
| Callbacks                                               | /** * @callback myCallback * @param {number} x - ... */ /** @type {myCallback} */ var cb; | 使用[@callback](https://www.html.cn/doc/jsdoc/tags-callback.html)标签指明一个回调。和@typedef标签是相同的，不同之处在于回调的类型始终是"function"。 |
| Type definitions                                        | 记录'id', 'name', 'age'属性的类型/** *  @typedef PropertiesHash *  @type {object} *  @property {string} id - an ID. *  @property {string} name - your name. *  @property {number} age - your age. * /  /** @type {PropertiesHash}  */ var props; | 您可以使用@typedef标签记录复杂类型，然后参考类型定义在你文档的其他地方。 |

**例子**

例如：

```javascript
/** @type {(string|Array.<string>)} */
var foo;
/** @type {number} */
var bar = 1;
```

在许多情况下，您可以包含一个类型表达式作为另一个标签的一部分，而不是在你的JSDoc注释块中包含独立@type标签。

例如，类型表达式可以有多个标签：

```javascript
/**
 * @type {number}
 * @const
 */
 var FOO = 1;
 // same as:
 /** @const {number} */
 var FOO = 1;
```

### 43.@typedef   记录一个自定义的类型 

**语法**

```javascript
@typedef [<type>] <namepath>
```

**概述**

@typedef标签在描述自定义类型时是很有用的，特别是如果你要反复引用它们的时候。这些类型可以在其它标签内使用，如 [@type ](https://www.html.cn/doc/jsdoc/tags-type.html)和 [@param](https://www.html.cn/doc/jsdoc/tags-param.html)。

使用@callback标签表明回调函数的类型。

**例子**

这个例子定义了一个联合类型的参数，表示可以包含数字或字符串。

例如，使用[@typedef](https://www.html.cn/doc/jsdoc/tags-callback.html)标签：

```javascript
/**
 * A number, or a string containing a number.
 * @typedef {(number|string)} NumberLike
 */
 /**
 * Set the magic number.
 * @param {NumberLike} x - The magic number.
 */
 function setMagicNumber(x) {
}
```

本实例定义了一个更复杂的类型，一个对象的几个属性，并设置其namepath（名称路径） 所以使用该类型将与类一起显示。由于该类型定义实际上不是由类暴露， 习惯上，以记录类型定义作为内部构件。

使用@typedef记录的复杂类型的一类，例如：

```
/**
 * The complete Triforce, or one or more components of the Triforce.
 * @typedef {Object} WishGranter~Triforce
 * @property {boolean} hasCourage - Indicates whether the Courage component is present.
 * @property {boolean} hasPower - Indicates whether the Power component is present.
 * @property {boolean} hasWisdom - Indicates whether the Wisdom component is present.
 */
 /**
 * A class for granting wishes, powered by the Triforce.
 * @class
 * @param {...WishGranter~Triforce} triforce - One to three {@link WishGranter~Triforce} objects
 * containing all three components of the Triforce.
 */
 function WishGranter() {}
```

### 44.@variation   区分具有相同名称的不同的对象。 

**语法**

```javascript
@variation  <variationNumber>
```

**概述**

有时候，你的代码可能包括多个同longname的标识符。 例如，你可能有两个全局类，并且顶级的命名空间叫做`Widget`。 在这些情况下， "{@link Widget}" 或者 "@memberof Widget" 是什么意思呢？全局命名空间，还是全局类？

@variatio有助于JSDoc区分相同longname的不同标识符。例如，如果"@variation 2"被添加到JSDoc注释块中的Widget类，"{@link Widget(2)}"将指向这个类，"{@link Widget}"将指向命名空间。此外，当你使用[@alias](https://www.html.cn/doc/jsdoc/tags-alias.html) 或 [@name](https://www.html.cn/doc/jsdoc/tags-name.html)标签指定标识符的时候，还可以包括variatio （例如，"@alias Widget(2)"）。

您可以给@variation标签提供任何值，只要值和longname组合导致全球唯一的longname的版本。最佳做法是，用一个可预测的模式进行选择值，这将使它更容易为您记录您的代码。

**例子**

下面的示例使用@variation标签来区分Widget类和Widget命名空间。

例如，使用@variation标签：

```javascript
/**
 * The Widget namespace.
 * @namespace Widget
 */// you can also use '@class Widget(2)' and omit the @variation tag/**
 * The Widget class. Defaults to the properties in {@link Widget.properties}.
 * @class
 * @variation 2
 * @param {Object} props - Name-value pairs to add to the widget.
 */function Widget(props) {}/**
 * Properties added by default to a new {@link Widget(2)} instance.
 */Widget.properties = {    /**
     * Indicates whether the widget is shiny.
     */
    shiny: true,    /**
     * Indicates whether the widget is metallic.
     */
    metallic: true};
```

### 45.@version   描述版本信息。 

**概述**

@version标签后面的文本将被用于表示该项的版本。

**例子**

例如，使用@version标签：

```javascript
/**
 * Solves equations of the form a * x = b. Returns the value
 * of x.
 * @version 1.2.3
 * @tutorial solver
 */
 function solver(a, b) {
     return b / a;
}
```

### 46.@abstract   这个成员必须在继承类中实现（或重写）。 

 **别名**

 `@virtual` 

**Overview(概述)**

该成员（一般指父类的方法）必须在继承的子类中实现（或重写）。

**Example （例子）**

例如，父类的抽象方法，子类实现该方法：

```javascript
/**
 * Generic dairy product.
 * @constructor
 */
function DairyProduct() {}

/**
 * Check whether the dairy product is solid at room temperature.
 * @abstract
 * @return {boolean}
 */
DairyProduct.prototype.isSolid = function() {
    throw new Error('must be implemented by subclass!');
};

/**
 * Cool, refreshing milk.
 * @constructor
 * @augments DairyProduct
 */
function Milk() {}

/**
 * Check whether milk is solid at room temperature.
 * @return {boolean} Always returns false.
 */
Milk.prototype.isSolid = function() {
    return false;
};
```

### 47.@access   指定该成员的访问级别（私有 private，公共 public，或保护 protected） 

**Syntax（语法）**

```javascript
@access <private|protected|public>
```

**Overview（概述）**

指定该成员的访问级别（私有 private，公共 public，或保护 protected）。你可以使用与`@access`标签同义的其他标签：

- `@access private` 等价于 `@private`;
- `@access protected` 等价于 `@protected`;
- `@access public` 等价于 `@public`;

私有成员不会显示在生成的输出文档中，除非通过`-p/--private`命令行选项运行JSDoc。在JSDoc3.3.0或更高版本，您还可以使用[`-a/--access`命令行](https://www.html.cn/doc/jsdoc/about-commandline.html)选项来改变这种行为。

请注意，doclet的*访问级别*不用于他们的`scope`(作用域)。例如，如果`Parent`有一个名为`child`的内部变量，那么这个内部变量将被记录为`@public`,`child`变量仍然是被视为一个内部变量，其namepath为`Parent~child`。 换一种说法，`child`变量将有一个内部作用域，即使这个变量是公开的。 要更改doclet的作用域，请使用[`@instance`](https://www.html.cn/doc/jsdoc/tags-instance.html), [`@static`,](https://www.html.cn/doc/jsdoc/tags-static.html) 和 [`@global`](https://www.html.cn/doc/jsdoc/tags-global.html)标签。

**Examples（例子）**

例如，可以使用与`@access`标签同义的其他标签：

```javascript
/** @constructor */
function Thingy() {

    /** @access private */
    var foo = 0;

    /** @access protected */
    this._bar = 1;

    /** @access public */
    this.pez = 2;

}

// same as...

/** @constructor */
function OtherThingy() {

    /** @private */
    var foo = 0;

    /** @protected */
    this._bar = 1;

    /** @public */
    this.pez = 2;

}
```

### 48.@alias   标记成员有一个别名 

**Syntax （语法）**

```javascript
@alias <aliasNamepath>
```

**Overview （概述）**

`@alias`标签标记成员有一个别名。如果该成员有不同的名称，JSDoc把所有引用作为这个成员。如果你在一个内部函数中定义一个类的时候，这个标签是非常有用的;在这种情况下，您可以使用`@alias`标签告诉JSDoc，这个类如何在您的应用程序中暴露出来。

虽然`@alias`标签听起来类似于[`@name`](https://www.html.cn/doc/jsdoc/tags-name.html)标签，但是他们的行为非常不同。`@name`标签告诉JSDoc忽略与注释关联的所有代码。例如，当JSDoc处理下面的代码的时候，它忽略了`bar`的注释关联到一个`foo`函数：

```javascript
/**
 * Bar function.
 * @name bar
 */function foo() {}
```

`@alias`标记告诉JSDoc这是一个伪装，成员A实际上叫做成员B。例如，当JSDoc处理下面代码的时候，它承认`foo`是一个函数，然后在生产的文档中将`foo`改名为`bar`：

```javascript
/**
 * Bar function.
 * @alias bar
 */function foo() {}
```

**Examples（例子）**

假设你正在使用类框架，希望当你定义一个类的时候，你只要传递一个构造函数。您可以使用@alias标签告诉JSDoc，这个类如何在您的应用程序中暴露出来。

在下面的例子中，在@alias标签告诉JSDoc处理匿名函数，就好像它是 “trackr.CookieManager”类的构造函数。在这个函数中，JSDoc将`this`关键字解释为trackr.CookieManager，因此，“value”方法的namepath(名称路径)为“trackr.CookieManager＃value”。

例如，匿名的构造函数使用`@alias`:

```javascript
Klass('trackr.CookieManager',

    /**
     * @class
     * @alias trackr.CookieManager
     * @param {Object} kv
     */
    function(kv) {
        /** The value. */
        this.value = kv;
    }

);
```

您也可以在一个立即调用的函数表达式（IIFE）中创建的成员中使用`@alias`标签。@alias标签告诉JSDoc，这些成员都暴露在IIFE作用域之外的。

例如，命名空间的静态方法使用`@alias`:

```javascript
/** @namespace */
var Apple = {};

(function(ns) {
    /**
     * @namespace
     * @alias Apple.Core
     */
    var core = {};

    /** Documented as Apple.Core.seed */
    core.seed = function() {};

    ns.Core = core;
})(Apple);
```

对于那些对象字面量中定义的成员，可以使用@alias标签替代的[@lends](https://www.html.cn/doc/jsdoc/tags-lends.html)标记。

例如，对象常量使用`@alias`:

```javascript
// Documenting objectA with @alias

var objectA = (function() {

    /**
     * Documented as objectA
     * @alias objectA
     * @namespace
     */
    var x = {
        /**
         * Documented as objectA.myProperty
         * @member
         */
        myProperty: 'foo'
    };

    return x;
})();

// Documenting objectB with @lends

/**
 * Documented as objectB
 * @namespace
 */
var objectB = (function() {

    /** @lends objectB */
    var x = {
        /**
         * Documented as objectB.myProperty
         * @member
         */
        myProperty: 'bar'
    };

    return x;
})();
```

### 49.@augments   指名这个子类继承至哪个父类，后面需要加父类名 

 **别名**

@extends 

**Syntax(语法)**

```javascript
@augments <namepath>
```

**Overview（概述）**

`@augments` or`@extends`标签指明标识符继承自哪个父类，后面需要加父类名。你可以使用这个标签来记录基于类和并基于原型的继承。

在JSDoc3.3.0或更高版本中，如果一个标识符继承自多个父类，并且多个父类有同名的成员，JSDoc使用来自列出的JSDoc注释中最后一个父类的文档。

**Examples （例子）**

在下面的例子中，`Duck` 类被定义为`Animal`的子类。`Duck`实例和`Animal`实例具有相同的属性，以及 `speak`方法是`Duck`实例所独有的。

例如，描述一个父类和子类的关系：

```javascript
/**
 * @constructor
 */
function Animal() {
    /** Is this animal alive? */
    this.alive = true;
}

/**
 * @constructor
 * @augments Animal
 */
function Duck() {}
Duck.prototype = new Animal();

/** What do ducks say? */
Duck.prototype.speak = function() {
    if (this.alive) {
        alert('Quack!');
    }
};

var d = new Duck();
d.speak(); // Quack!
d.alive = false;
d.speak(); // (nothing)
```

在下面的例子中，`Duck` 类继承自`Flyable`和`Bird` 类，这两个父类都定义了一个`takeOff`方法。由于`@augments Bird` 是在 `Duck` 文档列表中最后，JSDoc自动使用`Bird#takeOff`注释来记录`Duck#takeOff`。

例如，用重写方法来实现多重继承：

```javascript
/**
 * Abstract class for things that can fly.
 * @class
 */
function Flyable() {
    this.canFly = true;
}

/** Take off. */
Flyable.prototype.takeOff = function() {
    // ...
};

/**
 * Abstract class representing a bird.
 * @class
 */
function Bird(canFly) {
    this.canFly = canFly;
}

/** Spread your wings and fly, if possible. */
Bird.prototype.takeOff = function() {
    if (this.canFly) {
        this._spreadWings()
            ._run()
            ._flapWings();
    }
};

/**
 * Class representing a duck.
 * @class
 * @augments Flyable
 * @augments Bird
 */
function Duck() {}

// Described in the docs as "Spread your wings and fly, if possible."
Duck.prototype.takeOff = function() {
    // ...
};
```

### 50.@author   指定项目的作者； 

**Syntax（语法）**

```javascript
@author  <name> [<emailAddress>]
```

**Overview（概述）**

`@author`标签标识一个项目的作者。在JSDoc3.2和更高版本中，如果作者的名字后面跟着尖括号括起来的电子邮件地址， 默认模板将电子邮件地址转换为`mailto:`链接。

**Examples（例子）**

例如，描述项目的作者

```javascript
/**
 * @author Jane Smith <jsmith@example.com>
 */
 function MyClass() {}
```

### 51.@borrows   这个对象使用另一个对象的某些东西 

**Syntax(语法)**

```javascript
@borrows <that namepath> as <this namepath>
```

**Overview（概述）**

@borrows标签允许您将另一个标识符的描述添加到你的当前描述。

如果你不止在一个地方引用同一个函数，但是你又不想重复添加同样的文档描述到多个地方，这个时候非常有用。

**Examples（例子）**

在这个例子中，"trstr"函数存在文档，但"util.trim"只是使用不同的名称引用相同的功能。

例如，复制trstr的文档描述给util.trim

```javascript
/**
 * @namespace
 * @borrows trstr as trim
 */var util = {
    trim: trstr
};/**
 * Remove whitespace from around a string.
 * @param {string} str
 */
 function trstr(str) {
}
```

### 52.@callback   描述一个回调函数。 

**Syntax(语法)**

```javascript
@callback <namepath>
```

**Overview（概述）**

描述一个回调函数。`@Callback`标签提供回调函数（可传递给其他函数）的描述，包括回调的参数和返回值。你可以包涵任何一个你能提供给`@method`标签。

一旦你定义了一个回调，你可以像`@typedef` 标签所定义的自定义类型那样使用它。尤其是，你可以使用回调的名称作为类型名称。这样您可以使你明确指明函数参数应包含那个回调。

如果你想要一个回调显示为某个特定类的类型定义，可以给回调加一个`namepath`，指示它是某个类的一个内部函数。您还可以定义一个引用多个类引用的全局的回调类型。

**Examples（例子）**

例如,描述一个指定类回调:

```javascript
/**
 * @class
 */
function Requester() {}

/**
 * Send a request.
 * @param {Requester~requestCallback} cb - The callback that handles the response.
 */
Requester.prototype.send = function(cb) {
    // code
};

/**
 * This callback is displayed as part of the Requester class.
 * @callback Requester~requestCallback
 * @param {number} responseCode
 * @param {string} responseMessage
 */
```

例如,描述一个全局回调:

```javascript
/**
 * @class
 */
function Requester() {}

/**
 * Send a request.
 * @param {requestCallback} cb - The callback that handles the response.
 */
Requester.prototype.send = function(cb) {
    // code
};

/**
 * This callback is displayed as a global member.
 * @callback requestCallback
 * @param {number} responseCode
 * @param {string} responseMessage
 */
```

### 53.@class   此函数旨在需要使用"new"关键字调用，即构造函数。 

 别名

`@constructor` 

**Syntax（语法）**

```javascript
@class [<type> <name>]
```

**Overview（概述）**

`@class`标签标明函数是一个构造器函数，意味着需要使用 `new` 关键字来返回一个实例，即使用 new 关键字实例化。

**Examples（例子）**

例如，一个函数构建一个Person实例：

```javascript
/**
 * Creates a new Person.
 * @class
 */
function Person() {
}

var p = new Person();
```

### 54.@classdesc   使用后面的文字来描述整个类。 

**Syntax（语法）**

```javascript
@classdesc <some description>
```

**Overview（概述）**

`@classdesc`标签用于为类提供一个描述，这样和构造函数的描述区分开来。`@classdesc`标签应该与 [@class (或 @constructor)标签](https://www.html.cn/doc/jsdoc/tags-class.html)

结合使用。

在JSDoc 3 中 `@classdesc`标签的功能和以前版本中的`@class`标签的功能是重复的。截至第3版，`@class`标签的语法和功能和现在的`@constructor`标签是完全匹配的，并且@classdesc标签更明确地传达其目的：记录一类的描述。

**Examples（例子）**

如下所示，一个类有两个添加描述的地方，一个适用于函数本身，而另一个一般适用于类。

例如,一个同时具有构造函数描述和类说明的doclet：

```javascript
/**
 * This is a description of the MyClass constructor function.
 * @class
 * @classdesc This is a description of the MyClass class.
 */
function MyClass() {
}
```

### 55.@constant   记录一个对象作为一个常量。 

 **别名**

`@const` 

**Syntax（语法）**

```javascript
@constant [<type> <name>]
```

**Overview（概述）**

@constant 标签指明这个对象是一个常量。

**Examples（例子）**

在这个实例中我们记录一个字符串常量。注意，虽然代码使用`const`关键字，对于JSDoc来说，这不是必需的。如果你的JavaScript宿主环境尚不支持常量声明，`@const`描述可以很有效地用在`var`声明上。

例如，一个字符串常量表示红色：

```javascript
/** @constant
    @type {string}
    @default
*/
const RED = 'FF0000';

/** @constant {number} */
var ONE = 1;
```

注意，实例中在`@type`标签中提供了一个类型。是可选的。另外可选的`@default`标签用在这里也一样，这里将自动添加任何指定的值（例如， 'FF0000'）给文档。

### 56.@constructs   这个函数成员将成为类的构造函数。 

**Overview（概述）**

当使用对象字面量形式定义类（例如使用`@lends`标签）时，可使用`@constructs`标签标明这个函数用来作为类的构造实例。

**Syntax（语法）**

```javascript
@constructs [<name>]
```

**Examples（例子）**

例如， @constructs 和 @lends 结合使用：

```javascript
var Person = makeClass(
    /** @lends Person.prototype */
    {
        /** @constructs */
        initialize: function(name) {
            this.name = name;
        },
        /** Describe me. */
        say: function(message) {
            return this.name + " says: " + message;
        }
    }
);
```

不和`@lends`结合使用的时候，你必须提供一个类的名称:

```javascript
makeClass('Menu',
    /**
     * @constructs Menu
     * @param items
     */
    function (items) { },
    {
        /** @memberof Menu# */
        show: function(){
        }
    }
);
```

### 57.@copyright   描述一些版权信息 

**Syntax（语法）**

```javascript
@copyright <some copyright text> 
```

**Overview（概述）**

`@copyright`标签是用来描述一个文件的版权信息。一般和[@file ](https://www.html.cn/doc/jsdoc/tags-file.html)标签结合使用。

**Examples（例子）**

```javascript
/**
 * @file This is my cool script.
 * @copyright Michael Mathews 2011
 */
```

### 58.@default   记录默认值。 

 **别名**

@defaultvalue 

**Syntax（语法）**

```javascript
@default [<some value>]
```

**Overview（概述）**

@default标签可以让你记录标识的赋值。可以在标签后面跟上他的值，或者当值是一个唯一被分配的简单值(可以是：一个字符串，数字，布尔值或`null`)的时候，你可以让JSDoc从源代码中获取值，自动记录 。

**Examples（例子）**

在本实例中,一个常量被记录。该常数的值为`0xff0000`。通过添加@default标签，这个值将自动添加到文档。

例如，记录一个常量的数值：

```javascript
/**
 *  @constant
 *  @default
 */
const RED = 0xff0000;
```

### 59.@deprecated   说明这已不再是首选方法。 

**Syntax（语法）**

```javascript
@deprecated [<some text>]
```

**Overview（概述）**

@deprecated 标签指明一个标识在你代码中已经被弃用。

**Examples（例子）**

您可以单独使用的@deprecated标签，或包括一些文本，来详细说明为什么要弃用。

例如，描述一个old函数从2.0版本开始已经被弃用：

```javascript
/**
 * @deprecated since version 2.0
 */
function old() {
}
```

### 60.@description   描述一个标识. 

 **别名**

@desc 

**Syntax（语法）**

```javascript
@description <some description>
```

**Overview（概述）**

`@description`标签允许您提供一般描述。该说明可能包括HTML标签。如果[Markdown 插件](https://www.html.cn/doc/jsdoc/plugins-markdown.html)启用的话，它也可包括Markdown格式。

**Examples（例子）**

如果在注释开始的地方添加描述，那么可省略`@description`标签。

例如，不用@description标签描述一个标识：

```javascript
/**
 * Add two numbers.
 * @param {number} a
 * @param {number} b
 * @returns {number}
 */
function add(a, b) {
    return a + b;
}
```

如果通过使用@description标签添加描述，你可以将描述放置在JSDoc注释的任何地方。

例如，用@description标签描述一个标识：

```javascript
/**
 * @param {number} a
 * @param {number} b
 * @returns {number}
 * @description Add two numbers.
 */function add(a, b) {    return a + b;
}
```

### 61.@enum   描述一个相关属性的集合。 

**Syntax（语法）**

```javascript
@enum [<type>]
```

**Overview（概述）**

@enum标签描述一个静态属性值的全部相同的集合。枚举类似一个属性的集合，除了枚举自己的描述注释之外，属性都记录在容器内部的注释中。通常这种标签是与`@ReadOnly`结合使用，作为一个枚举通常表示常量的集合。

**Examples（例子）**

这个例子表明如何记录一个对象，这个对象有三个可能的状态的值。请注意，枚举成员可以添加一个可选的描述，如果你的希望的话。你也可以覆盖类型，如下所示的"MAYBE" -- 默认情况下，枚举成员将被记录为与枚举本身相同的类型。

例如，一个数字枚举，表示的3种状态：

```javascript
/**
 * Enum for tri-state values.
 * @readonly
 * @enum {number}
 */
var triState = {
    /** The true value */
    TRUE: 1,
    FALSE: -1,
    /** @type {boolean} */
    MAYBE: true
};
```

### 62.@event   描述一个事件。 

**语法**

```javascript
@event <className>#[event:]<eventName>
```

**概述**

描述一个事件。@event标签允许您描述一个可触发的事件，一个典型的事件是由对象定义的一组属性来表示。

标签来定义事件的具体类型，您可以使用`@fires`标记，以表明这个种方法可以触发该事件。你还可以使用`@listens`标签，以指示表明用这个表示来侦听该事件。

JSDoc自动预先考虑命名空间的每个`event:` 事件的名称。在一般情况下，当您在其他的doclet链接到该事件时,你必须包含这个命名空间。（`@fires`标签是一个特殊的例外，它可以让你忽略命名空间。）

**注意**：JSDoc3使用`@event` doclet 来描述事件的内容。与此相反，JSDoc Toolkit 2中使用`@event`的doclet识别一个函数，当同名事件发生时，这个函数是否会被执行。

**示例**

下面的示例演示如何记录一个`Hurl`类中名为`snowball`事件。该事件包含一个带有单独属性的对象。

例如，描述一个作为事件的行数：

```javascript
/**
 * Throw a snowball.
 *
 * @fires Hurl#snowball
 */
Hurl.prototype.snowball = function() {
    /**
     * Snowball event.
     *
     * @event Hurl#snowball
     * @type {object}
     * @property {boolean} isPacked - Indicates whether the snowball is tightly packed.
     */
    this.emit('snowball', {
        isPacked: this._snowball.isPacked
    });
};
```

例如，使用一个命名doclet来描述一个事件：

```javascript
/**
 * Throw a snowball.
 *
 * @fires Hurl#snowball
 */
Hurl.prototype.snowball = function() {
    // ...
};

/**
 * Snowball event.
 *
 * @event Hurl#snowball
 * @type {object}
 * @property {boolean} isPacked - Indicates whether the snowball is tightly packed.
 */
```